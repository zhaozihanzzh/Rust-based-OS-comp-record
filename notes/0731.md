# 7 月 31 日

## rCore-SMP

由于 ```send_ipi``` 返回值一直有些异常，我觉得可能要先研究一下 IPI 的整个处理过程。

按照 rCore-Tutorial-Book 文档的说法，IPI 是作为 Supervisor Software Interrupts 接收的（内核在 S 特权级）。中断处理在 rCore-Tutorial-Book ch9 中介绍了一部分，如平台级中断控制器。（在读这个文档时发现里面提到了怎么做设备树解析，而我却自己瞎折腾了好几天……）在阅读时，发现第九章中提到，中断初始化在第三章已经讲过了，于是赶忙前往第三章。

### RISC-V 架构中的中断

中断和异常（如执行 ```ecall```）都是一种 Trap。但异常与 CPU 指令的执行是同步的，中断与 CPU 指令的执行是异步的。

如果中断的特权级低于 CPU 当前的特权级，则该中断会被屏蔽。否则，需要通过相应的 CSR 判断该中断是否会被屏蔽。（S 特权级既要 ```status.sie``` 置 1，还需要 ```sie.ssie```（软件中断）/```sie.stie```（时钟中断）/```sie.seie```（外部中断）置 1，才能让对应的中断不被屏蔽）在对中断进行软件处理时，具体到哪个特权级处理与一些中断代理 CSR 的设置有关。我尝试先给 ```sie.stie``` 置 1，然后再发送 IPI，但还是没取得什么效果。

## 总结

查找文档的资料让我意识到 rCore-Tutorial-v3 其实有较大的价值，只不过当时做实验不是用的这个，因此走了弯路。假如没有这些从不同地方集合到一起且与主题高度契合的材料的话，可能光弄明白一些 RISC-V 的技术细节就需要很长时间。下次继续研究 IPI 的问题。