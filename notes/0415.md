# 4 月 15 日

## Rustlings

完成了 lifetimes，iterators 和 box 部分。

## 特型对象

### 静态分发（static dispatching）

建立在泛型基础上，有点类似 C++ 的 template，编译时把相关函数针对不同类型全部生成，好处是性能好，坏处是代码体积大。

### 动态分发（dynamic dispatching）

不需要泛型。特型对象用像 ```Box<dyn Foo>``` 或 ```&dyn Foo``` 的形式来使用（相当于 C++ 中的对象指针）（Foo 是 trait），背后的数据类型要实现 Foo 特型，当使用动态分发时，只能在运行时进行方法分发，特型背后的具体数据类型被抹去（也就是说，传入的这个东西只能调用特型实现的方法，而不能去试图 match 它的类型然后调用类型相关的方法）。

这样做带来一定运行时开销。  

### 对象安全性

不是所有特型都可以以特型对象的形式安全地使用。特型是对象安全的，需要满足以下条件（不完整，见[对象安全条款](https://rustwiki.org/zh-CN/reference/items/traits.html#%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E6%9D%A1%E6%AC%BE) ）：

- 超类也是对象安全的；
- 不能以 Sized 为超特型；
- 可分发的关联函数：
    - 不带类型参数（尽管生存期参数可以有）
    - 除接收方（receiver）外，其他地方不能用 ```Self``` 类型
    - 接收方是引用或某种指针形式的类型，如 ```&Self```、```&mut Self```、```Box<Self>``` 等
    - 没有 where Self : Sized 约束

## 生命周期

通常情况下，引用具有隐式的生命周期，不需要额外关注；必要时也可以显式指定：
```rust
fn bar<'a>(x: &'a i32) {
    // ...
}
```
其中，```&'a i32``` 是一个 ```i32``` 类型的引用，其生命周期至少有 ```'a``` 那么长。```'a``` 是一个命名的生命周期参数。```<'a>``` 在泛型参数中声明生命周期参数。

一般情况下，编译器可以推断生命周期，不需要显式声明；但涉及多个引用或要返回引用的场景时，可能需要显示指定生命周期。

```rust
fn borrow_x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str;
```
在上面的函数中，所有输入和输出的引用有着同样的生命周期。也就是说，只要返回的引用还存在，那么引用 ```x``` 和 ```y``` 必须还存在。

```rust
fn borrow_p<'a, 'b>(p: &'a str, q: &'b str) -> &'a str;
```

除了引用外，结构体和结构体成员也可以具有生命周期参数：

```rust
struct Pizza(Vec<i32>);
struct PizzaSlice<'a> {
    pizza: &'a Pizza, // 结构体中的引用必须有显式的生命周期
    index: u32,
}

let s2;
{
    let p2 = Pizza(vec![1, 2, 3, 4]);
    s2 = PizzaSlice { pizza: &p2, index: 2};
}
// drop(s2); // Error: `p2` does not live long enough
```

### 生命周期之间的关系

```<'b : 'a>``` 表示 ```'b``` 的周期涵盖 ```'a``` 的生命周期：
```rust
struct Foo<'a, 'b> {
    v: &'a Vec<i32>,
    s: &'b str,
}
```

此时，实现结构体的方法时也需要指定生命周期：
```rust
impl<'a, 'b> Foo<'a, 'b> {
    fn new(v: &'a Vec<i32>, s: &'b str) -> Foo<'a, 'b> {
        Foo {
            v: v,
            s: s,
        }
    }
}
```
### 静态生命周期

```'static``` 表示整个程序的生命周期。所有 ```&str``` 字面值是 ```'static``` 的。

### 生命周期的解释

生命周期不会比所引用的数据的所有者活得更久。还是较为抽象，在实践中多领悟。

## 智能指针

- ```&T``` 和 ```&mut T```：尽量使用；编译时有检查，不够灵活
- ```Box<T>```（盒子）：数据分配在堆上面，指针是唯一的（类似 C++ 的 ```std::unique_ptr```）。可以创建 ```Box<T>``` 的引用。自动销毁对象。```Box``` 必须活到所有引用失效之后。
- ```std::rc::Rc<T>```：共享所有权的指针类型（类似 C++ 的 ```std::shared_ptr```），调用 Rc 的 ```clone()``` 方法会增加引用计数但不会拷贝数据，仅当引用计数为 1 时才能修改，当引用计数降为 0 时会释放对象。
    - ```Rc::get_mut(&mut shared)``` 返回 ```Option```，当引用计数为 1 时返回可变引用，当引用计数不为 1 时返回 ```None```。
- ```std::rc::Weak<T>```： 有环时，A 有 B 的 Rc，B 有 A 的 Rc，都不会被释放，故引入弱引用：弱引用不会增加强引用的计数。 ```Rc::downgrade``` 得到 Weak，Weak 再 ```upgrade``` 变成 Rc，除此之外 weak 干不了别的事（防止使用无效状态）。
- ```Cell```、```RefCell```：允许结构体内部可变性。
    - ```Cell```：为 ```Copy``` 类型提供内部可变性的格子类型。用 ```get```、```set``` 函数操作。
    - ```RefCell```：为任意类型提供内部可变性的格子类型。在运行时检查，通过 ```borrow``` 和 ```borrow_mut``` 来借用，如果已经被借用的话有可能不成功。```borrow``` 等方法这里不是线程安全的。
    ```rust
    struct Foo {
        x: Cell<i32>,
        y: RefCell<u32>,
    }
    ```
- ```*const T``` 和 ```*mut T```：像 C 一样的裸指针，需要用 unsafe 解引用，编写底层代码时用。

### 自动解引用

Rust 大多数情况下对变量做自动解引用操作：
- 对一个引用进行方法调用时；
- 将引用作为函数参数进行传递时；

## 总结

继续看一下并发编程部分。争取完成 Rustlings。