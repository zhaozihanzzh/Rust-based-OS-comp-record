# 4 月 4 日

## 所有权（Ownership）

如何保持性能并能确保安全性？——（显式）所有权是 Rust 的代表性特性之一。所有权几乎都在编译时检查，因此运行时开销很小。

### 所有权规则

Rust 每个值都有所有者，同一时刻只有一个所有者，当所有者失效时，值也被丢弃（回收）。

变量绑定拥有数据的所有权，绑定超出作用域时会自动释放所绑定的数据。

移动语义：
```rust
let v1 = vec![1, 2, 3];
let v2 = v1; // Ownership moves to v1
```
默认把所有权移交给 ```v2``` 并把 ```v1``` 置为无效，编译时即可检测。（编译器可能优化导致实际上并不把数据移动给 ```v2```）

为了方便函数调用传参等，有借用：对变量取引用来借用变量中数据所有权，当引用超过作用域，借用也结束。

```rust
for v in vs {
    // ...
}
```
会造成 ```vs``` 失效。除了获得所有权方式进行向量迭代外，还有以不可变方式借用、以可变方式借用来循环。

另外：
```rust
let mut v1 = v0;
aFunc(&mut v1); // 这样与 &v1 是不一样的。
```
是可变借用。

当一个变量有引用存在时，Rust 规定不能移交它所绑定的数据的所有权：
```rust
let v = vec![1, 2, 3];
let v_ref = &v;
let v_new = v; // Error
println!("{:?}", v_ref); // 如果没有这一行，在 2018 版之后可以在 Rust 中通过编译，因为 v_ref 已经失效。（非词法生命周期）
```

### Copy trait

表示一个类型可以拷贝，不用默认的移动语义。如，大多数基本类型（如 ```i32```、```char```），其拷贝的代价很低。包含引用的类型不是 Copy 类型（如 ```Vec```、```String```）。

### 借用规则

- 不能在某个对象不存在后继续保留对其引用；
- 一个对象可以同时存在多个不可变引用（```&T```）；
- 或仅有一个可变引用（```&mut T```）；
- 以上两者不能同时存在。

以上设计的一部分原因是并发。

### 切片

切片是特殊形态的引用，
```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```

## 总结

关于课件中的 Rust “自动解引用”相关的内容还不是很清楚。下次计划继续学习结构化数据。