# 5 月 20 日

## Rust 闭包

闭包（Lambda 函数、匿名函数）常在函数式语言中被应用。Rust 语言中闭包与所有权模型匹配。

闭包是引用了自由变量的函数。当闭包被调用时，执行函数体。

```rust
let foo2 = |x: i32| {
    let y = x * 2;
    let z = 4 + y;
    x + y + z
}
```

参数在两竖线之间（类型可省略）。之后是返回表达式（类型也可省略，这与函数不同）。

闭包与函数最大的不同是闭包可以包含它所在的环境。

```rust
let magic_num = 5;
let plus_magic = |x: i32| x + magic_num;
let more_magic = &mut magic_num; // Err!
```

此处，如果在闭包绑定后试图以冲突的方式借用 ```magic_num```，会发生编译错误。不过，如果用花括号单独包起 ```plus_magic``` 使其在超出作用域后被回收，那么 ```magic_num``` 所有权就又回来了。

在闭包需要创建比它的作用域活得更久时，需要移动闭包（韩老师说此时栈上发生的变化很复杂）：

```rust
fn make_closure(x: i32) -> Box<Fn(i32) -> i32> {
    let f = move |y| x + y;
}
```

有些闭包只能调用一次（转移走了所有权）。拥有数据所有权但不转移的闭包是可以多次调用的。

闭包根据所有权不同分别实现下列三种特型：

```Fn```：借用 self，也就是使用 ```&self```。
```FnMut```：可变方式借用 self，也就是使用 ```&mut self```。
```FnOnce```：获得 self 所有权。

## 总结

闭包这一部分是对前面落下的内容的一点补充。接下来忙学校事情并准备 lesson2。