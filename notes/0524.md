# 5 月 24 日

## Hypervisor 在 ARMv8 上的实现第二讲：ARMv8 第二阶段地址翻译与内存虚拟化

Hypervisor 上多个 OS 需要互相隔离。有两种各有优劣的方法：

### 影子分页

将 Gust 虚拟直接翻译成 Host 物理地址。

客户 OS 操作页表（如填入地址）时陷入 Hypervisor EL2 特权级中，由 Hypervisor 合并这两个映射（Hypervisor 拦截修改后写入自己想写的，软件维护数据结构保存 gPA->hPA 的映射）。影子页表实际上写的是 gVA -> hPA。

Hypervisor 拦截修改：

- TTBR0_EL1（虚拟地址高 16 位为 0 的页表基地址），TTBR1_EL1（虚拟地址高 16 位为 1 的页表基地址）（翻译页表项）
- Guest 页表：在影子页表中取消相应映射

### 第二阶段地址翻译

有硬件支持时，通常使用第二阶段地址翻译（二维分页 / 嵌套分页）。

Guest 虚拟 -> Guest 物理 -> Host 物理。硬件自动完成 gPA -> hPA。

| 影子分页 | 第二阶段地址翻译 |
|---------|---------------|
| 软件方法，不需要专门硬件支持 | 需要硬件支持 |

|复杂| 简单 |

|TLB 缺失开销小 | 大 |

| 映射修改开销大 | 小 |

| 页表切换开销大（每次 VMexit 进入 Hypervisor）| 小 |

| 内存空间占用 | 大 | 小 |

下节课上课说一下本节课两个小习题。

### ARMv8 两阶段地址翻译流程

客户页表基地址。

客户虚拟地址 -> 第一阶段基地址在 TTBR0/1_EL1 客户物理地址 -> 第二阶段基地址在 VTTBR_EL2 翻译得到主机物理地址

第二阶段缺页（gPA->hPA 时）：触发 Data Abort 异常，陷入 EL2

应用场景：页面换出，按需分配（不映射客户操作系统整个地址空间，只映射必要地址，当访问时引发缺页才填入页表项），MMIO 设备虚拟化

第二阶段缺页处理：

- ESR_EL2 寄存器，存储 Exception Code 等
- HPFAR_EL2：出错的 gPA
- FAR_EL2：出错的 hPA

Hypervisor 页表基地址在 TTBR0_EL2 中

## 总结

最近事情较多。考虑再三，还是要抓住重点，不能得过且过、逃避问题以求一时心安！